#!/usr/bin/env lua

local options = {
  install = {
    enable = true,
    desc = 'Install plugins',
  },
  update = {
    enable = true,
    desc = 'Update plugins',
  },
  clean = {
    enable = true,
    desc = 'Clean the directories',
  },
  --doctor = true,
  snapshot = {
    enable = true,
    multiple = true,
    dec = 'Check the plugins info',
  },
  --debug = true,
  dmodule = {
    enable = true,
    multiple = true,
    dec = 'Dynamic disable modules for debug',
  },
  help = {
    enable = true,
    dec = 'Show the usage of bot',
  },
  modules = {
    enable = true,
    dec = 'Show all modules',
  },
  makemodule = {
    enable = true,
    multiple = true,
    dec = 'Make a module from the template',
  }, -- to create a module project struct
}

------------------------------------------------
-- Vars to generate
local enabledArgs = {}
local enabledAndMultipleArgs = {}
local argument
------------------------------------------------
-- Iterate through options table
for key, value in pairs(options) do
  if value.enable then
    table.insert(enabledArgs, key)
    if value.multiple then
      table.insert(enabledAndMultipleArgs, key)
    end
  end
end

-- set install by default or load the argument
argument = #arg == 0 and 'install' or arg[1]

-- verify allowed multiple arguments
if #arg > 1 and not enabledAndMultipleArgs[argument] then
  error('Passed multiple arguments.')
end

-- Verify if the passed argument is enabled
if not enabledArgs[argument] then
  error('Unknow argument. ' .. argument)
end

-- Work with dmodule option (debug)
if argument == 'dmodule' then
  --   local modules = [[let g:disable_modules="]]
  --   ---@diagnostic disable-next-line: deprecated
  --   for _, k in pairs({ table.unpack(arg, 2, #arg) } or {}) do
  --     modules = modules .. ',' .. 'modules/' .. k .. '/plugins'
  --   end
  --   modules = modules .. '"'
  --   os.execute("nvim --cmd '" .. modules .. "'")
  --   return
  local disabled_modules_command = [[let g:disable_modules="]] .. arg[2] .. '"'
  os.execute("nvim --cmd '" .. disabled_modules_command .. "'")
  return
end

local handle
handle = assert(io.popen([[nvim --clean --handless --cmd 'echo $VIMRUNTIME|q' 2>&1]], 'r'))
if not handle then
  return
end

local rtp = handle:read('*a')
handle:close()

-- read config path
handle = assert(io.popen([[nvim --clean --headless --cmd 'echo stdpath("config")|q' 2>&1]], 'r'))
local config_path = handle:read('*a')
handle:close()

-- set the poackage path
package.path = package.path .. ';' .. rtp .. '/lua/vim/?.lua;' .. config_path .. '/lua/?.lua'

if argument == 'help' then
  local helper = require('code.helper')
  helper.green('Dope usage')
  -- Generate the 'usage' table
  local usage = {}
  for key, value in pairs(options) do
    local paddedKey = string.format('\t%-*s', largestKeySize, key)
    local description = '  ' .. value.desc
    table.insert(usage, { paddedKey, description })
  end
  local wblue = helper.write('blue')
  local wwhite = helper.write('white')
  for _, msg in pairs(usage) do
    wblue(msg[1])
    wwhite(msg[2])
    print()
  end
  os.exit()
end

-- read data path
handle = assert(io.popen([[nvim --clean --headless --cmd 'echo stdpath("data")|q' 2>&1]], 'r'))
local data_path = handle:read('*a')
handle:close()

local cli = require('core.cli')

cli.rtp = rtp
cli.config_path = config_path
cli.data_path = data_path

-- env init
cli:env_init()

---@diagnostic disable-next-line: deprecated
cli:meta(argument)(table.unpack(arg, 2))
